[{"categories":null,"contents":"First contribution to another project on Github ever! :)\nIt was very small, the library was a very small and new library that wanted to groups lots of functionalities pertaining to strings for Common Lisp. The creator/maintener asked for help on the lisp subreddit and I gave it a try. It was a good way to get my feet wet, a very small project with a responsive maintener that took the time to explains things to me on how to contribute on Github and such.\n","permalink":"https://www.julienrouse.com/projects/contributions/cl-string/","tags":["common-lisp","string","lisp"],"title":"First contribution: cl-string"},{"categories":null,"contents":"It feels good to fix the theme I use for the blog, I give back to a tool I will use for some time hopefully :)\nThe problem was that when looking at blog post with full resolution on my laptop, it displayed nicely. But when viewing it with smartphone resolution, it looked like this:\n  After some duckduckgoing, I stumbled upon box-sizing: border-box, an element I have not used before.I went to MDN to see what is was MDN page on box-sizing, then looked around if it could be that element tripping me up.\nBut according to that doc, because the CSS used border-box instead of content-box, my content should have behaved nicely and not overflowing.\nAfter more time looking around, a StackOverflow response once again saved the day. When using border-box on a container, you have to set the width on the inner child.\nI added width: 100% on the inner child, and \u0026ldquo;voila\u0026rdquo;:\n  ","permalink":"https://www.julienrouse.com/projects/contributions/hugo-resume/","tags":["css","hugo-resume","responsive design"],"title":"hugo-resume fix some css"},{"categories":null,"contents":" Part2: Going further with Svelte using components and props Introduction This article is the second part of a tutorial aiming at discovering Svelte[1] while building a game. I also wrote a very short post on Svelte and the idea behind this tutorial. Below you can find the links to check those posts or other parts of the tutorial.\n introduction to Svelte part1: Start of the tutorial: making a Derivative Idle clone with Svelte part2: Going further with Svelte using components and props part3: Adding upgrades to the game  Objectives for this part In this part we will learn how to use components, props and a state store to grow our game further.\nMake more buildings using components Right now we have one building producing money. That\u0026rsquo;s a start but it is not enough. What we want now is to make many more buildings.\nOne way to do that would be to copy-paste the following code to add a new building:\n1 2 3 4 5 6 7 8 9 10  \u0026lt;-- App.svelte --\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} buildings bought, next one cost {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;You gain {productionPerTick}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} buildings bought, next one cost {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;You gain {productionPerTick}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   Try it yourself, it makes a second building. The problem is that the two buildings are identical, and they share their internal state. The number of building bought, the cost of it, how much money it generates each tick\u0026hellip;\nWe need a way to encapsulate those information locally to have each building handle this for itself.\nAnd that is what components are for! (It\u0026rsquo;s the same concept in React[2] and Angular[3]). When you need to repeat the same independent elements (with slight variations) in different places, components are the way to go. They are also a nice way to have building block (think Lego) for your application. Usually you can have big components for the header, footer and main page. Then you can have smaller components like forms and menus that you can reuse in bigger components. And you can also compose your smaller components from even smaller components. It creates a tree architecture, with the root being often named App, the main entry point to your app, and then the leaf and nodes are other components used to build your app.\nTo create one, you need to create a .svelte file. (You can see that App.svelte is our root component here).Then inside the component you can declare some logic inside the \u0026lt;script\u0026gt; tag, some style inside the \u0026lt;style\u0026gt; tag and then a html template. The script and style part are local to the component by default. You can declare a new component Test.svelte that look like that:\n1 2 3 4 5 6 7 8  \u0026lt;!-- Test.svelte --\u0026gt; \u0026lt;style\u0026gt; button { background: red; } \u0026lt;/style\u0026gt; \u0026lt;button\u0026gt;Test button\u0026lt;/button\u0026gt;   Then import it in our App.svelte to use it:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  ... import Test from \u0026#39;./Test.svelte\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; ... \u0026lt;/style\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} buildings bought, next one cost {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;You gain {productionPerTick}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} buildings bought, next one cost {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;You gain {productionPerTick}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt; \u0026lt;Test\u0026gt;\u0026lt;/Test\u0026gt;   And the result:\n  You see that even so we declared a red background for \u0026lt;button\u0026gt;, because we declared it inside the component, the CSS is scoped and don\u0026rsquo;t interfere with the other elements on the page.\nLet\u0026rsquo;s go back to making a component for our buildings. You can delete Test.svelte. You can also delete in App.svelte the import to Test.svelte and the \u0026lt;Test\u0026gt;\u0026lt;/Test\u0026gt; code in the template.\nNow let\u0026rsquo;s create a component for our building. Create a file named Building.svelte and we are gonna remove every parts relating to our building from App.svelte to put it inside Building.svelte.\nWe are gonna remove everything from App.svelte except we gonna import the Building component, keep the declaration for money and in the template keep the title and insert two Building components.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  import Building from \u0026#39;./Building.svelte\u0026#39;; // variable declarations  let money = 20; // reactive declarations  // function declarations  // lifecycle functions \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;h1\u0026gt;You have {money} $!\u0026lt;/h1\u0026gt; \u0026lt;Building\u0026gt;\u0026lt;/Building\u0026gt; \u0026lt;Building\u0026gt;\u0026lt;/Building\u0026gt;   And inside the Building.svelte we have now:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54  \u0026lt;!-- Building.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  import { onMount } from \u0026#39;svelte\u0026#39;; // variable declarations  let money = 20; let numberOfBuilding = 0; let buildingProduction = 1; // $ produced per building per tick  let tickSpeed = 1000; // reactive declarations  $: cantBuy = cost \u0026gt; money; $: cost = (numberOfBuilding + 1) * 5; $: productionPerTick = numberOfBuilding * buildingProduction; // function declarations  // update the values of `money` and `numberBuildings`  function updateNumbers(){ money -= cost; numberOfBuilding += 1 } // update `money` with `productionPerTick` and set a timeout to call itself after `tickSpeed` ms  function updateMoney(){ money += productionPerTick; setTimeout(updateMoney, tickSpeed); } // lifecycle functions  onMount(() =\u0026gt; { updateMoney(); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; button { outline: 1px solid black; background: aliceblue; cursor: pointer; } button.cantbuy { background: #555; color: #DDD; cursor: default; } \u0026lt;/style\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} buildings bought, next one cost {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;You gain {productionPerTick}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   You can see we have kept only one \u0026lt;button\u0026gt; inside Building.svelte but we have inserted \u0026lt;Building\u0026gt;\u0026lt;/Building\u0026gt; twice in App.svelte to have two independent buildings.\nThat\u0026rsquo;s great! But if you test if, you\u0026rsquo;ll see a new problem. To highlight, let\u0026rsquo;s alter slightly the building to show for each building their money variable:\n1 2 3 4 5 6 7  \u0026lt;!-- Building.svelte --\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;Money: {money}$\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} buildings bought, next one cost {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;You gain {productionPerTick}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   When you click on the buildings, you see that they are independent, but a bit too much! They don\u0026rsquo;t share a common money value anymore, each one use its own, and when they produce, it only goes to their own money stash as well. That is not what we want. We would like for them to have a shared money value, and then handle the rest of their state independently.\nUsing the store to handle global state One way to have some global state that can be shared among components is to have a store with value that components can subscribe to. They can also update the value if you allow them to, and any change to the value are propagated back to other component subscribing to that value as well. It is the same idea that React/Redux uses (or Reagent/re-frame4 in the ClojureScript ecosystem) .\nLet\u0026rsquo;s create our store, we need a JS file that we will call store.js and put some code in it: (I use /* store.js */ instead of \u0026lt;!-- store.js --\u0026gt; to show you that the code belongs to store.js because it\u0026rsquo;s no longer a template file, but a proper JS file. It allows you to copy paste my snippet without having an error into your editor.)\n1 2 3 4  /* store.js */ import { writable } from \u0026#39;svelte/store\u0026#39;; export const money = writable(20);    And now we can use it inside our App.svelte and Building.svelte.\nIn App.svelte, we need to import it, remove the local variable declaration and change slightly the template where we used it.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  ... import { money } from \u0026#39;./store.js\u0026#39;; // variable declarations  // we removed let money = 20;  ... \u0026lt;/script\u0026gt; \u0026lt;h1\u0026gt;You have {$money} $!\u0026lt;/h1\u0026gt; \u0026lt;Building\u0026gt;\u0026lt;/Building\u0026gt; \u0026lt;Building\u0026gt;\u0026lt;/Building\u0026gt;   Read from the store To reference a value from the store, you prepend the dollar sign $ before it\u0026rsquo;s name. Here to access the value of money in the template we use $money. What it does in reality is auto-subscribe to the store value, and unsubscribe to it when the component is destroyed using the onDestroy lifecycle functions. onDestroy is kind of the opposite of onMount, it is called just after the component is unmounted from the DOM.\nYou can also opt out of the automatic subscribe and unsubscribe by doing it yourself, which allow more control over it. Let see what it would have looked like:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  \u0026lt;!-- ManualSubscribeToMoney.svelte --\u0026gt; \u0026lt;script\u0026gt; import { money } from \u0026#39;./store.js\u0026#39; import { onDestroy } from \u0026#39;svelte\u0026#39; let money_value; // here we subscribe to \u0026#39;money\u0026#39; and assign it\u0026#39;s value to \u0026#39;money_value\u0026#39;  // each time \u0026#39;money\u0026#39; change, it send it\u0026#39;s new value to \u0026#39;money_value\u0026#39; to keep it up to date.  const unsubscribe = money.subscribe(value =\u0026gt; { money_value = value; }); // here we unsubscribe to \u0026#39;money\u0026#39; when the component is unmounted.  onDestroy(unsubscribe); \u0026lt;/script\u0026gt; \u0026lt;!-- and here we can use \u0026#39;money_value\u0026#39; instead of $money. --\u0026gt; \u0026lt;h1\u0026gt;You have {money_value} $!\u0026lt;/h1\u0026gt;   Because it\u0026rsquo;s much shorter to use the shorthand, I\u0026rsquo;ll use for the rest of the tutorial. But keep in mind of what it does behind the scene.\nWrite to the store (if the value is a writable) You can\u0026rsquo;t update the value of the store like this: $money += 1. You need to use the methods update or set. For example if you want to update the value of money to add 1:\n1 2  // n refer to the old value of money, and n + 1 will be the new value money.update(n =\u0026gt; n + 1)    And if you want to give a totally new value to it you can use set:\n1 2  // set money to the greatest number ever money.set(42)    For more information on the store: Svelte store tutorial first and later Svelte doc to have more information on Writable, Readable, derived store value and get().\nGoing back to our project Now that we know how to read and write to the store, we can update Building.svelte. We need to import the store, change every instance of money with $money and also change the way we change the value of money using update.\nWe are gonna declare a new function that will hide the fact that money is a store value.\n1 2 3 4  // update the value of `money` to the store, adding `n` to it. function updateMoney(n){ money.update(m =\u0026gt; m + n); }    But doing so, we need to rename the old updateMoney that was launching the setTimeout to launchSetTimeout. The name was not good before, and it is still not good, if you have any suggestion, I\u0026rsquo;ll gladly take it! And we can replace every instance where we add money += something; by updateMoney(something);. After all the transformation the code look like that (keeping only the parts that changed):\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46  \u0026lt;!-- Building.svelte--\u0026gt; \u0026lt;script\u0026gt; // import declarations  ... import { money } from \u0026#39;./store.js\u0026#39;; // variable declarations  ... // reactive declarations  $: cantBuy = cost \u0026gt; $money; ... // function declarations  // update the value of `money` to the store, adding `n` to it.  function updateMoney(n){ money.update(m =\u0026gt; m + n); } // update the values of `money` and `numberBuildings`  function updateNumbers(){ updateMoney(-cost); numberOfBuilding += 1 } // update `money` with `productionPerTick` and set a timeout to call itself after `tickSpeed` ms  function launchTimeout(){ updateMoney(productionPerTick); setTimeout(launchTimeout, tickSpeed); } // lifecycle functions  onMount(() =\u0026gt; { launchTimeout(); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; ... \u0026lt;/style\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;Money: {$money}$\u0026lt;/p\u0026gt; ... \u0026lt;/button\u0026gt;   Now you can see that both the value of money in App.svelte and both Building.svelte is shared, but each building keep their numbers local otherwise.\n  Naming our building with props A very short step, now that we have many buildings, it could be nice to give them a name.\nBut remember that if we declare a variable inside a component, every instance of that component will have the same value for that variable. Not very helpful to have every building have the same name.\nWhat we need is called props. To draw an analogy, props are to a component what parameters are to a function. Props are used to initialize the component with some values. They are an essential building block because they allow to re-use component by giving them the flexibility they need.\nTo declare a prop, it\u0026rsquo;s like a variable declaration but with the keyword export added at the front of the declaration. And also we can replace on the template the reference to money with a reference to name.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!-- Building.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  ... // variable declarations  ... // prop declarations  export let name; // you can also give default value to your prop: export let name = \u0026#34;Producer\u0026#34;;  ... \u0026lt;/script\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;h3\u0026gt;{name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} buildings bought, next one cost {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;You gain {productionPerTick}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   And to define the prop value, you define it like an HTML attribute on the Building tag.\n1 2 3 4  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;Building name=\u0026#34;1th Derivative\u0026#34;\u0026gt;\u0026lt;/Building\u0026gt; \u0026lt;Building name=\u0026#34;Combinatorics\u0026#34;\u0026gt;\u0026lt;/Building\u0026gt;   And here is the result:\n  Digging a bit about what props enable Using props will allow us to customize a little more each building.\nWe can now change many aspect of them like :\n their initial cost their initial number (we can imagine starting off with a few buildings already built after buying an upgrade) what they produce. Right now it\u0026rsquo;s money but they could produce another currency or even other buildings! what they cost. Their cost could be another currency, another building or a combination of those. (Or even cost tick, accelerating or slowing down the game a you buy this building) they could also have a maximum number of unit. (Example no more than 30 \u0026ldquo;Combinatorics\u0026rdquo; buildings and no limit for the \u0026ldquo;1th Derivative\u0026rdquo; building). And a lot more!  As a starting point, let\u0026rsquo;s change what they produce.\nBuilding producing proofs In the original Derivative Clicker game, the primary currency is money but there is a secondary currency named proofs that can be produced and is used to buy powerful buildings. (It is also one of the two element determining the amount of prestige currency you earn when you use the reset/prestige mechanic.).\nLet\u0026rsquo;s implement proof :)\nFor the same reason money was put into the store, we are gonna put proofs there too.\n1 2 3 4 5  /* store.js */ import { writable } from \u0026#39;svelte/store\u0026#39;; export const money = writable(20); export const proofs = writable(0);    We can then change the building component to replace explicit references to money to a generic currencyProduced that will can be either money or proofs.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  \u0026lt;!-- Building.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  ... // variable declarations  ... // props declaration  ... export let currencyProduced = money // By default, building will produce money  // reactive declarations  ... // function declarations  ... function updateCurrencyProduced(n){ currencyProduced.update(m =\u0026gt; m + n); } ... function launchTimeout(){ updateCurrencyProduced(productionPerTick); // change updateMoney to updateCurrencyProduced  setTimeout(launchTimeout, tickSpeed); } \u0026lt;/script\u0026gt;   Then to tie it up, in App.svelte we can import proofs from the store, and pass it as a prop to the building we want. (and update the display of the value as well).\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  ... import { money, proofs } from \u0026#39;./store.js\u0026#39;; ... \u0026lt;/script\u0026gt; \u0026lt;h1\u0026gt;You have {$money}$ and {$proofs} proofs!\u0026lt;/h1\u0026gt; \u0026lt;Building name=\u0026#34;1th Derivative\u0026#34;\u0026gt;\u0026lt;/Building\u0026gt; \u0026lt;Building name=\u0026#34;Combinatorics\u0026#34; currencyProduced={proofs}\u0026gt;\u0026lt;/Building\u0026gt;   Because gave a default value to currencyProduced for buildings, we don\u0026rsquo;t need to use the prop for every building. But if we want to make it explicit, we can:\n1 2  \u0026lt;Building name=\u0026#34;1th Derivative\u0026#34; currencyProduced={money}\u0026gt;\u0026lt;/Building\u0026gt; \u0026lt;Building name=\u0026#34;Combinatorics\u0026#34; currencyProduced={proofs}\u0026gt;\u0026lt;/Building\u0026gt;   Note also that we did not need to import proofs into Building.svelte (and we only need to import money because we use it as the default value for currencyProduced). We just import it in App.svelte and pass either money or proofs to the buildings. Then we rely on the fact that every store object can be read with $ and updated with the update method. The only constraint is that what we give as a props to the buildings must be a writable store reference on a number (because we update it with + inside the building component). To relax this constraint, we could fire an event in the building component that could be handled in his parent component, updating the currency however it wants to. But this feel a bit heavy, and we won\u0026rsquo;t go this way (for now).\nFixing the UI Now our \u0026ldquo;Combinatorics\u0026rdquo; building produces proofs, but we still display that it produces money.\nWe could do a function with lots of if then else to display either \u0026ldquo;$\u0026rdquo; or \u0026ldquo;proof\u0026rdquo; or \u0026ldquo;proofs\u0026rdquo; or something else depending on what currency the building produce. Or we could add another prop to handle that. It means that we could have two building producing the same currency but displaying it differently. I\u0026rsquo;ll go with the first way of doing it because it will be quicker, but the second one is definitely more flexible (but I don\u0026rsquo;t think that will be needed).\nAnd because we are fixing the UI, we will also make it closer to Derivative Clicker. (at least for buildings)\nSo we want a function that will display the currency depending on what we produce. We will add it to a new file: utils.js because that function can be re-used in more than one component and is not tied to only one of them.\n1 2 3 4 5 6 7 8 9 10 11  /* utils.js */ import { money, proofs } from \u0026#39;./store.js\u0026#39;; function currencyToString(currency){ result = \u0026#34;?\u0026#34;; if (currency === money) result = \u0026#34;$\u0026#34;; else if (currency === proofs) result = \u0026#34;proofs\u0026#34; return result; };    I use a if else here, but a switch case will probably scale better in readability if we get a lot more cases to handle. We will see how that pan out.\nLet\u0026rsquo;s use that function in Building.svelte:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;!-- Building.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  ... import { currencyToString } from \u0026#39;./utils.js\u0026#39;; ... \u0026lt;/script\u0026gt; ... \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;h3\u0026gt;{name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{buildingProduction}{currencyToString(currencyProduced)}/tick: costs {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Owned:{numberOfBuilding} ({numberOfBuilding})\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   To get closer to the original game I changed buildingProductionPerTick to buildingProduction. Both information are useful, we could display both, but I\u0026rsquo;ll stick with the original design and display only buildingProduction.\nAlso I used \u0026lt;p\u0026gt;Owned:{numberOfBuilding} ({numberOfBuilding})\u0026lt;/p\u0026gt;. It seems weird right now, but we will edit it later when we implement building producing buildings. Then it will be \u0026lt;p\u0026gt;Owned:{numberOfBuildingTotal} ({numberOfBuildingBought})\u0026lt;/p\u0026gt;.\nIn App.svelte, we can use the function as well:\n1 2 3 4 5 6 7 8 9 10 11 12  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  ... import { currencyToString } from \u0026#39;./utils.js\u0026#39;; ... \u0026lt;/script\u0026gt; \u0026lt;h1\u0026gt;You have {$money}{currencyToString(money)} and {$proofs}{currencyToString(proofs)}!\u0026lt;/h1\u0026gt; ...   If you follow closely, you may have noticed that the currency for the cost of the building is still hardcoded as $ and not currencyToString(money). It\u0026rsquo;s because for now we have not looked into buying building with other currency than money. We will change it when times come to implement that feature.\nNote also that currencyToString() might possibly have been a component. (And that might have been a better implementation choice, I\u0026rsquo;m not sure). Try it out if you want!\nBuilding producing buildings Now that we have building producing proofs, what about buildings producing buildings?\nTo do that, we need to change a few things:\n in store.js we are gonna had new variables for each building we have so we can synchronize their number. in Building.svelte we need to use this new variable, and update it when needed. Be careful when updating as the new variable will be a writable, not a plain number. We will need to use $ to dereference the value and update()to update it. We also need to define new props to use those variables. in App.svelte we have to update the props and the template html to add the second level of buildings.  1 2 3 4 5 6 7 8 9 10  /* store.js */ ... // first level buildings export const firstDerivativeNum = writable(0); export const combinatoricsNum = writable(0); // second level buildings export const secondDerivativeNum = writable(0);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38  \u0026lt;!-- Building.js --\u0026gt; \u0026lt;script\u0026gt; // import declarations  ... // variable declarations  let buildingProduction = 1; // $ produced per building per tick  let tickSpeed = 1000; // props declarations  export let name; export let currencyProduced = money; export let numberOfBuilding; // reactive declarations  ... $: cost = ($numberOfBuilding + 1) * 5; $: productionPerTick = $numberOfBuilding * buildingProduction; // function declaration  ... // update the values of `currencyProduced` and `numberBuildings`  function updateNumbers(){ updateMoney(-cost); numberOfBuilding.update(n =\u0026gt; n + 1); } ... \u0026lt;/script\u0026gt; ... \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;h3\u0026gt;{name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{buildingProduction}{currencyToString(currencyProduced)}/tick: costs {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Owned:{$numberOfBuilding} ({$numberOfBuilding})\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;!-- App.js --\u0026gt; \u0026lt;script\u0026gt; // import declarations import Building from \u0026#39;./Building.svelte\u0026#39;; import { money, proofs, firstDerivativeNum, secondDerivativeNum, combinatoricsNum } from \u0026#39;./store.js\u0026#39;; import { currencyToString } from \u0026#39;./utils.js\u0026#39;; // variable declarations // reactive declarations // function declarations // lifecycle functions \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;h1\u0026gt;You have {$money}{currencyToString(money)} and {$proofs}{currencyToString(proofs)}!\u0026lt;/h1\u0026gt; \u0026lt;Building name=\u0026#34;1th Derivative\u0026#34; numberOfBuilding={firstDerivativeNum}\u0026gt;\u0026lt;/Building\u0026gt; \u0026lt;Building name=\u0026#34;Combinatorics\u0026#34; currencyProduced={proofs} numberOfBuilding={combinatoricsNum}\u0026gt;\u0026lt;/Building\u0026gt; \u0026lt;Building name=\u0026#34;2nde Derivative\u0026#34; currencyProduced={firstDerivativeNum} numberOfBuilding={secondDerivativeNum}\u0026gt;\u0026lt;/Building\u0026gt;   Now that we have that, we can generate other buildings :)\nA little tweak to fix the UI again, the \u0026ldquo;2nd Derivative\u0026rdquo; building display a ? instead of the name of the building it produces. To fix that we need to update utils.js.\n1 2 3 4 5 6 7 8 9 10 11 12  /* utils.js */ import { money, proofs, firstDerivativeNum } from \u0026#39;./store.js\u0026#39; // Returns a string representing `currency`. If `currency` is not recognized, returns \u0026#39;?\u0026#39; export function currencyToString(c){ ... else if (c === firstDerivativeNum) result = \u0026#34; 1st Derivative\u0026#34; return result; }    To be fair, the UI needs a lot more fixing but it will do for now ;)\nBy doing this we introduced a ~bug~ feature with the costs of the buildings, if you start by buying a building that produces another building, this building\u0026rsquo;s costs will go up even so we did not buy any manually. We will ~fix this bug~ reverse this feature in the next tutorial when we will implement upgrades.\nRecap That\u0026rsquo;s it for this second part of the tutorial. Below is the full code we have so far.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  import Building from \u0026#39;./Building.svelte\u0026#39;; import { money, proofs, firstDerivativeNum, secondDerivativeNum, combinatoricsNum } from \u0026#39;./store.js\u0026#39;; import { currencyToString } from \u0026#39;./utils.js\u0026#39;; // variable declarations  // reactive declarations  // function declarations  // lifecycle functions \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; \u0026lt;/style\u0026gt; \u0026lt;h1\u0026gt;You have {$money}{currencyToString(money)} and {$proofs}{currencyToString(proofs)}!\u0026lt;/h1\u0026gt; \u0026lt;Building name=\u0026#34;1th Derivative\u0026#34; numberOfBuilding={firstDerivativeNum}\u0026gt;\u0026lt;/Building\u0026gt; \u0026lt;Building name=\u0026#34;Combinatorics\u0026#34; currencyProduced={proofs} numberOfBuilding={combinatoricsNum}\u0026gt;\u0026lt;/Building\u0026gt; \u0026lt;Building name=\u0026#34;2nde Derivative\u0026#34; currencyProduced={firstDerivativeNum} numberOfBuilding={secondDerivativeNum}\u0026gt;\u0026lt;/Building\u0026gt;  1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70  \u0026lt;!-- Building.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  import { onMount } from \u0026#39;svelte\u0026#39;; import { money } from \u0026#39;./store.js\u0026#39;; import { currencyToString } from \u0026#39;./utils.js\u0026#39; // variable declarations  let buildingProduction = 1; // $ produced per building per tick  let tickSpeed = 1000; // props declarations  export let name; export let currencyProduced = money; export let numberOfBuilding; // reactive declarations  $: cantBuy = cost \u0026gt; $money; $: cost = ($numberOfBuilding + 1) * 5; $: productionPerTick = $numberOfBuilding * buildingProduction; // function declarations  // update the value of `currencyProduced` to the store, adding `n` to it.  function updateMoney(n){ money.update(m =\u0026gt; m + n); } // update the value of `currencyProduced` to the store, adding `n` to it.  function updateCurrencyProduced(n){ currencyProduced.update(m =\u0026gt; m + n); } // update the values of `currencyProduced` and `numberBuildings`  function updateNumbers(){ updateMoney(-cost); numberOfBuilding.update(n =\u0026gt; n + 1); } // update `currencyProduced` with `productionPerTick` and set a timeout to call itself after `tickSpeed` ms  function launchTimeout(){ updateCurrencyProduced(productionPerTick); setTimeout(launchTimeout, tickSpeed); } // lifecycle functions  onMount(() =\u0026gt; { launchTimeout(); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; button { outline: 1px solid black; background: aliceblue; cursor: pointer; } button.cantbuy { background: #555; color: #DDD; cursor: default; } \u0026lt;/style\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;h3\u0026gt;{name}\u0026lt;/h3\u0026gt; \u0026lt;p\u0026gt;{buildingProduction}{currencyToString(currencyProduced)}/tick: costs {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;Owned:{$numberOfBuilding} ({$numberOfBuilding})\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;  1 2 3 4 5 6 7 8 9 10 11 12  /* store.js */ import { writable } from \u0026#39;svelte/store\u0026#39;; export const money = writable(20); export const proofs = writable(0); // first level buildings export const firstDerivativeNum = writable(0); export const combinatoricsNum = writable(0); // second level buildings export const secondDerivativeNum = writable(0);   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  /* utils.js */ import { money, proofs, firstDerivativeNum } from \u0026#39;./store.js\u0026#39; // Returns a string representing `currency`. If `currency` is not recognized, returns \u0026#39;?\u0026#39; export function currencyToString(c){ let result = \u0026#34;?\u0026#34;; if (c === money) result = \u0026#34;$\u0026#34;; else if (c === proofs) result = \u0026#34; proofs\u0026#34; else if (c === firstDerivativeNum) result = \u0026#34; 1st Derivative\u0026#34; return result; }    And below you can see the result:\n  Objectives for the next parts There are quite a few things to implement still:\n Update the stats recap at the top Make buildings have varying costs Upgrades for our buildings Prestige layer Options (Save, Export Save, Load Save, Stats, number formatting Balancing the game  We will continue in the next part: Coming soon.\nYou can also play with the project in the Svelte REPL or play the game made so far (hosted by Surge) .\n","permalink":"https://www.julienrouse.com/blog/tutorial-for-idle-game-svelte-part2/","tags":["svelte","SPA","game","tutorial","idle"],"title":"Tutorial for an Idle game with Svelte (Part2)"},{"categories":null,"contents":" Webpack-cli crashes for Windows users, but only on Monday It seems like a headline from the Onion1. But unfortunately it\u0026rsquo;s not.\nWebpack-cli2 had a bug3 recently because it tried to display a message for donations on the terminal when using it. But that message was only displayed on Monday(because there were complaints about seeing the donation message every time you were running a build).\nThen a bug was introduced into that code because it relies on process.getuid which is not available on Windows, making the CLI crash but only on Windows and on Monday \\(**)/.\nSimilar story If you like weird bug story, you can also read:\n Crashes only on Wednesday Cannot print on Tuesday! The 500-mile mail   https://www.theonion.com/\r[return] https://github.com/webpack/webpack-cli\r[return] https://github.com/webpack/webpack-cli/issues/962\r[return]   ","permalink":"https://www.julienrouse.com/blog/webpack-cli-crashes-only-on-monday/","tags":["short","bug","webpack","webpack-cli","not-the-onion","javascript"],"title":"Webpack-cli crashes only on Monday"},{"categories":null,"contents":" Making a Derivative Idle clone with Svelte This is the first part of a multi part tutorial on making a game with Svelte1. (If you have not read it already, I made an introduction to Svelte you can find right below).\n introduction to Svelte part1: Start of the tutorial: making a Derivative Idle clone with Svelte part2: Going further with Svelte using components and props part3: Adding upgrades to the game  Tutorial Let\u0026rsquo;s start the Derivative Clicker2 tutorial :) I\u0026rsquo;ll try to introduce concept as they come but you are expected to already know a bit of HTML, CSS and some programming concepts like variables, functions, loop and recursion.\nFor the following tutorial I\u0026rsquo;ll use the Svelte REPL3 but you can also follow instructions on the Svelte Getting Started4 page to set yourself up with your favorite editor.\nDisclaimer A little word of warning, it\u0026rsquo;s my first Svelte project so I may do things that are not optimal.\nAlso I will write some invalid HTML (invalid as in not W3C compliant) to not have to use CSS until the very end of the tutorial because it\u0026rsquo;s not the focus of this project. I will take care of pointing out when I take those shortcuts.\nAnd also my English is far from perfect so hit me up with a message at contact AT julienrouse.com when you see an error so I can correct it and try to learn from my mistake to not do it again!\nIntroduction to the game and scope of the tutorial What is Derivative Clicker Before trying to create a copy of a game, lets talk a bit about what is the essence of this particular game. Derivative Clicker is an idle game. The idle genre resolve around making a number go big, usually by buying things that generate some form of currency. Then with that currency you can buy more stuff that generate more currency. There is usually no end game, just the pleasure to see your number grow bigger and bigger (until the browser can\u0026rsquo;t display your number because it\u0026rsquo;s too big :) ). Sometimes the game continue to generate currency even when you are not online but not always (not in this case).\nHere you start with no cash and when you click on a button you gain some cash. Then after clicking a few times, with your hard earned cash you can buy something (I\u0026rsquo;ll call it \u0026ldquo;building\u0026rdquo; in the rest of the tutorial) that will generate a little bit of cash every tick. There is a tick every 1000ms (1 second) but as you progress, ticks can go faster, accelerating production. Then as you go further into the game, you can buy more buildings that generate either more cash or more buildings. (Like Russian dolls, there is always an extra layer).\nYou can also buy upgrades for your buildings that will make then more efficient, less costly or upgrades that will simulate clicks. (And some games have more elaborate ways of upgrading the game).\nAlso because the cost of buildings will grow exponentially but the growth of cash production will be less than exponential, at some point we will hit a time wall where we can\u0026rsquo;t buy new buildings before a long time. That is where reset comes in. The reset (or prestige) mechanic allow you to reset the game entirely from the start. But why would you do that? Because resetting gives you some form of bonus that helps you progress further into the game. Some elaborate games features more than one prestige layer. For our case, prestige gives us prestige currency that gives a percentage bonus to our building production. How many prestige currency you get depends on how big your numbers are at the time you reset. The prestige currency is also used to buy some powerful upgrades (for example unlocking new buildings) that allow to progress further. So you have to balance keeping the prestige currency for it\u0026rsquo;s production boost or spending it to gain other bonuses.\nWhat we will aim for  Create buildings that generate cash Create buildings that generate other currencies Create buildings that generate other buildings Have some upgrades Have some form of prestige mechanic Have some form of statistics for the game Use Svelte :) And discover its many features  Also note that you can peak at the source code of the game (itself forked from here). For this tutorial we won\u0026rsquo;t follow this code, but create a game similar to it from scratch.\nHello World The first line \u0026lt;!-- App.svelte --\u0026gt; is to indicate the name of the file, here App.svelte and it\u0026rsquo;s just for the tutorial. You do not need to include that line in your project, it\u0026rsquo;s for helping you follow along the tutorial.\n1 2 3 4 5 6  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; let name = \u0026#39;world\u0026#39;; \u0026lt;/script\u0026gt; \u0026lt;h1\u0026gt;Hello {name}!\u0026lt;/h1\u0026gt;   File ending in .svelte are kind of like .html. They are mostly composed of HTML tags and components. (We will see after how to define our own components).\nYou can also define some logic inside \u0026lt;script\u0026gt;\u0026lt;/script\u0026gt; and reference it inside the html template. Above we declared a variable name and gave it the value \u0026quot;world\u0026quot;. Then inside the template we reference it with the syntax {name} to inject its value.\nIf you use the REPL, you should see on the right side in the result pane a big bold Hello world!.\n  Creating the first building If you recall the little introduction on idle games, building are things that you can buy and then they generate something every tick. (or every X tick, or twice per tick or whenever. Here we will start by producing money every tick.)\nSo for this first step we need to:\n keep track of cash (our primary currency) keep track of how many numbers of building we bought (cause the price of the building depends on the number of building, and how much cash is generated each tick is also dependent on how many buildings there are). create a function that will be used every tick (to gain currency)  Let\u0026rsquo;s keep track of cash in our game : let money = 20 and start with 20 units of it. And by modifying a bit the Hello World example, you can show the amount of money.\n1 2 3 4 5 6  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; let money = 20; \u0026lt;/script\u0026gt; \u0026lt;h1\u0026gt; You have {money} $ \u0026lt;/h1\u0026gt;   Next to represent a building, we will use a button. If you click on it, you buy it, deducting its price from your money.\nWe need two variables: one for the price and one for the number of building bought:\n1 2 3 4 5 6  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; let money = 20; let cost = 5; let numberOfBuilding = 0; \u0026lt;/script\u0026gt;   And then we can use those variable in the template with curly braces syntax {} we saw earlier:\n1 2 3 4  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;button\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} building bought, next one cost {cost}$\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   So far so good :)\nNow we need to actually do something when we click on the button.\nBuying a building with event and event handler We add an event handler to do something when you click on the button. In Svelte you can intercept any event with on: followed by the event name. Here the event is click so we use on:click={clickHandler}. clickHandler is a function that is called when a click is registered. For example:\n1 2 3 4  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;button on:click={()=\u0026gt;alert(\u0026#39;The button was clicked\u0026#39;)}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} building bought, next one cost {cost}$\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   Will trigger a JS alert each time the button is clicked.\nIn our case we want to update our cash, the number of building and the cost of the next building. Let\u0026rsquo;s define a function updateNumbers that do exactly that. *Note that for now we use a linear growth function to calculate building cost, but usually idle games define a cost with exponential growth. We will change that later.\n1 2 3 4 5 6 7 8 9 10 11 12 13  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; let money = 20; let cost = 5; let numberOfBuilding = 0; // function called when clicking on the building button  function updateNumbers(){ money -= cost; //shorthand for money = money - cost  numberOfBuilding += 1 //numberOfBuilding = numberOfBuilding + 1  cost = (numberOfBuilding + 1) * 5; } \u0026lt;/script\u0026gt;   And the template for the button:\n1 2 3 4  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;button on:click={updateNumbers}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} building bought, next one cost {cost}$\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   This seems to works :) But if you click more than three times on the button you will see that our money goes into negative value :( We need to restrict buying only when we have enough money.\n  Restrict buying building only when we have the money What we want is to block the button when we have less money than the cost. We could write it that way:\n1 2 3 4  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;button on:click={updateNumbers} disabled=\u0026#34;{cost \u0026gt; money}\u0026#34;\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} building bought, next one cost {cost}$\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   But maybe we will need the boolean condition cost \u0026gt; money in other places as well, and it is better not to repeat many times the same logic (see DRY principle). If later on we need to change it, we\u0026rsquo;d have to find all the places we used it. (Spoiler alert: we will need to have that condition in more than one place, and we will also need to change it slightly later). To solve that little problem, we are going to use reactive declarations5.\nRefactoring using reactive declarations Reactive declarations are a way to declare variable that depends on other variables. When the value of the variables they depend on change, their own value will be recomputed (they react to change hence the name).\nHere we are going to write one such reactive declaration\n1 2 3 4 5 6 7 8  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; ... // here goes the code for the variable declarations  $: cantBuy = cost \u0026gt; money ... // here goes the rest of the code \u0026lt;/script\u0026gt;   And now we can use it in our button:\n1 2 3 4  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;button on:click={updateNumbers} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} bought, next one cost {cost}$\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   Below you can see the result, we can no longer click on the button when we can\u0026rsquo;t afford it.\n  Another place we can use reactive declarations is with the cost variable. Remember that to update the cost we used cost = (numberOfBuilding + 1) * 5;. That too can be expressed as a reactive declaration.\n1 2 3 4 5 6 7 8 9 10 11  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; //instead of let cost = 5, replace it by  $: cost = (numberOfBuilding + 1) * 5; //change the updateNumbers function  function updateNumbers(){ money -= cost; numberOfBuilding += 1 } \u0026lt;/script\u0026gt;   We no longer need to update the cost here, reactive declaration does it for us when we update numberOfBuilding.\nMid tutorial recap Let\u0026rsquo;s have a look at the full code until now and see how far we got.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; let money = 20; let numberOfBuilding = 0; // Reactive declarations  $: cantBuy = cost \u0026gt; money; $: cost = (numberOfBuilding + 1) * 5; // function called when clicking on the building button  function updateNumbers(){ money -= cost; //shorthand for money = money - cost  numberOfBuilding += 1 //numberOfBuilding = numberOfBuilding + 1  } \u0026lt;/script\u0026gt; \u0026lt;h1\u0026gt;You have {money} $!\u0026lt;/h1\u0026gt; \u0026lt;button on:click={updateNumbers} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} bought, next one cost {cost}$\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   We can buy buildings, can\u0026rsquo;t buy them when we don\u0026rsquo;t have the money. We need now to make them generate money!\nMaking buildings generates money To do that, we need to trigger a function every X millisecond. In JS we can use setTimeout.\nWe will declare a tickSpeed variable that will be the X for the interval for setTimeout. Later on it will allow us to increase or decrease (mostly decrease) the value of tickSpeed to accelerate the game.\nWe will also declare a variable buildingProduction to represent how much money each building produce every tick.\nAnd last we declare a new function updateMoney that will update the amount of money we have and trigger a timeOut to get called again after tickSpeed milliseconds.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; ... //variable declarations  let tickSpeed = 1000 // tickSpeed is expressed in ms  let buildingProduction = 1; // $ produced per building per tick  ... //reactive declarations  // functions declaration  function updateMoney(){ money += numberOfBuilding * buildingProduction; setTimeout(updateMoney, tickSpeed); } updateMoney(); // Call the function to start the update loop.  \u0026lt;/script\u0026gt;   And voilà! Now when you buy buildings, you should see the money going up each second!\nChanges to the UI For the first part of the tutorial we implemented all the feature we planned to but we could add some visual changes.\nAdd more stats Now that we earn money each tick, wouldn\u0026rsquo;t that be nice to see how much we earn?\nIn the template we can just add \u0026lt;p\u0026gt;You gain {numberOfBuilding * buildingProduction}$ / tick.\u0026lt;/p\u0026gt; to have more information:\n1 2 3 4  \u0026lt;button on:click={updateNumbers} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} buildings bought, next one cost {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;You gain {numberOfBuilding * buildingProduction}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   NOTE: yes I inserted two \u0026lt;p\u0026gt; inside the \u0026lt;button. It is not the recommended way to make two lines of text one below the other in a button but for now it will do. (I checked a w3c validator6 and indeed it is not valid.)\nNow you can test it, buy a couple buildings and you\u0026rsquo;ll see how much money you get each tick.\nBut by doing that, we introduced some redundancy. We used numberOfBuilding * buildingProduction which is already used in the function updateMoney. We can utilize a reactive declaration again to not repeat this operation in multiple place, and also replace it in the code in all the places it was used.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; // variable declarations  ... // reactive declarations  ... $: productionPerTick = numberOfBuilding * buildingProduction; // function declarations  ... function updateMoney(){ money += productionPerTick; setTimeout(updateMoney, tickSpeed); } \u0026lt;/script\u0026gt; ... \u0026lt;button on:click={updateNumbers} disabled={cantBuy}\u0026gt; ... \u0026lt;p\u0026gt;You gain {productionPerTick}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   But when you replace everything that way, you get an error: can't access lexical declaration 'productionPerTick' before initialization. What is means it that we try to use productionPerTick (which rely on other variables) before Svelte has even initialized those variables.\nTo resolve this problem, we will have to use some lifecycle functions.\nIntroducing lifecycle functions: onMount Svelte (like React and Angular) provides function that you can redefine to customize the comportment of the components.\nHere we can use onMount to only call the function updateMoney (and consequently use productionPerTick) only once Svelte has been initialized. (Or rather, once Svelte has initialized the App component).\nTo be able to use onMount we need to import it first.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; // imports declaration  import { onMount } from \u0026#39;svelte\u0026#39;; // variable declarations  ... // reactive declarations  ... // function declarations  ... // lifecycle functions  onMount(() =\u0026gt; { updateMoney(); }); \u0026lt;/script\u0026gt;   Once we do that the error disappear and the application works again. :)\nFor more information on onMount and other lifecycle functions, see the documentation and the onMount tutorial.\nAdding some visual cues And to finish this tutorial, let\u0026rsquo;s add some visual cues for the button.\nWe are going to change the background color for the button and change the mouse cursor depending on if we can buy it or not.\nWe can style elements directly into our .svelte files with the \u0026lt;style\u0026gt; tag. We are defining a default style for the \u0026lt;button\u0026gt; tag then a style for \u0026lt;button\u0026gt; that has the cantbuy class\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; ... \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; button { outline: 1px solid black; background: aliceblue; cursor: pointer; } button.cantbuy { background: #555; color: #DDD; cursor: default; } \u0026lt;/style\u0026gt;   Then we need to add this cantbuy class to the \u0026lt;button\u0026gt; only when we cannot buy it. Luckily we can re-use the reactive declaration cantBuy.\n1 2 3 4  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; ... \u0026lt;/button\u0026gt;   Here class:cantbuy={cantBuy} means Svelte will add the class cantbuy to the element only when the variable cantBuy is true. You can also write it with a ternary expression: class={cantBuy ? 'cantbuy' : ''}.\nConclusion This close the first part of this tutorial.\nBelow is the full code:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56  \u0026lt;!-- App.svelte --\u0026gt; \u0026lt;script\u0026gt; // import declarations  import { onMount } from \u0026#39;svelte\u0026#39;; // variable declarations  let money = 20; let numberOfBuilding = 0; let buildingProduction = 1; // $ produced per building per tick  let tickSpeed = 1000; // reactive declarations  $: cantBuy = cost \u0026gt; money; $: cost = (numberOfBuilding + 1) * 5; $: productionPerTick = numberOfBuilding * buildingProduction; // function declarations  // update the values of `money` and `numberBuildings`  function updateNumbers(){ money -= cost; numberOfBuilding += 1 } // update `money` with `productionPerTick` and set a timeout to call itself after `tickSpeed` ms  function updateMoney(){ money += productionPerTick; setTimeout(updateMoney, tickSpeed); } // lifecycle functions  onMount(() =\u0026gt; { updateMoney(); }); \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; button { outline: 1px solid black; background: aliceblue; cursor: pointer; } button.cantbuy { background: #555; color: #DDD; cursor: default; } \u0026lt;/style\u0026gt; \u0026lt;h1\u0026gt;You have {money} $!\u0026lt;/h1\u0026gt; \u0026lt;button on:click={updateNumbers} class:cantbuy={cantBuy} disabled={cantBuy}\u0026gt; \u0026lt;p\u0026gt;{numberOfBuilding} buildings bought, next one cost {cost}$.\u0026lt;/p\u0026gt; \u0026lt;p\u0026gt;You gain {productionPerTick}$ / tick.\u0026lt;/p\u0026gt; \u0026lt;/button\u0026gt;   You can play with the example in the Svelte REPL yourself.\nYou can also play the game we made so far here (hosted by Surge7).\nTo continue the tutorial, part2: Going further with Svelte using components and props (coming soon) :) We will build more than one building, create components to isolate our logic around buildings and continue to implement the game mechanics.\n https://svelte.dev/\r[return] http://gzgreg.github.io/DerivativeClicker/\r[return] https://svelte.dev/repl/hello-world?version=3.5.1\r[return] https://svelte.dev/blog/the-easiest-way-to-get-started\r[return] https://svelte.dev/tutorial/reactive-declarations\r[return] https://validator.w3.org\r[return] https://surge.sh/\r[return]   ","permalink":"https://www.julienrouse.com/blog/tutorial-for-idle-game-svelte-part1/","tags":["svelte","SPA","game","tutorial","idle"],"title":"Tutorial for an Idle game with Svelte (Part1)"},{"categories":null,"contents":" Introduction to Svelte I wanted to try out Svelte1 so I made a little clone of a game called Derivative Clicker2. Following is a very quick presentation of what is Svelte (and how it compares to other reactive framework like React3, Angular4, etc) then a multi part tutorial on how to make a little game app with Svelte.\n introduction to Svelte part1: Start of the tutorial: making a Derivative Idle clone with Svelte part2: Going further with Svelte using components and props: Coming soon  Svelte Svelte is in competition with React, Angular and other framework to build reactive Single Page Application, but the difference is Svelte shifts the work from the browser to the compiler. It still delivers Reactive Single page application but with a very reduced size. Similar initiative can be found as well with Aurelia5.\nThe project went to version 3 a month ago (early may 2019), I think it\u0026rsquo;s a good time to try it out :)\nPROS The Svelte tutorial6 is great, it takes about an hour or so and is very well done. It uses the Svelte REPL7 and it introduces concepts very smoothly. Also it uses mostly the same concepts as React, Vue8 and Angular. If you know at least one of those you should pick it up quickly. (Component, reactive bindings, props, event forwarding, state store, component life cycle and slots to name a few concepts used) .\nAlso the Svelte website features a very nice REPL that you can use to test Svelte app without installing anything. When you are ready for the next step, the get started section9 is handy. It\u0026rsquo;s just a matter of cloning a template from a git10 repository and use the tools you are used to: npm11 or yarn12, webpack13, rollup14 or browserify15. And for the deployment, there are instructions a quick setup with Now16 and Surge17 or you can choose you favorite deployment option as you would for any other JS or TypeScript project.\nAnother pro, look at this article for a RealWorld benchmark to get a feel of how Svelte can be very slim compared to its rivals. (Note that the benchmark was done with Svelte v2, and right now it is already Svelte v3, so take it with a grain of salt).\nCONS I think it got traction recently but it still is not widely used so there not much educational material yet. If you can\u0026rsquo;t do with only the official tutorial and API documentation, you should wait a bit more.\nAlso Svelte miss features like routing (but this is apparently addressed in the sister framework Sapper18 which aims to be a replacement for Next.js19).\nAnd last but not least, it has some weird syntax choices. The dollar sign $ has two different uses dependent on the context.\n1 2  let count = 0; $: doubled = count * 2; // here doubled is a \u0026#39;derived\u0026#39; value on \u0026#39;count\u0026#39;, it will automatically recalculate itself if count changes   1 2  \u0026lt;p\u0026gt; My name is {$name} \u0026lt;/p\u0026gt; \u0026lt;!-- Here $name is a reference to name, a value in a state store --\u0026gt;   I don\u0026rsquo;t like that choice. Note also that the second syntax is a shorthand syntax, you can subscribe manually to values in the store and name them without the $ so if you really care about that you can opt out (at the price of 3-4 lines of manual wiring).\nAnd syntax for conditional in template is also not very sexy:\n1 2 3  {{ #if condition }} \u0026lt;p\u0026gt; Inside the if \u0026lt;/p\u0026gt; {{ /if}}    But I guess it\u0026rsquo;s more a matter of personal taste.\nPracticing Svelte by building a game To continue onto the first part of the tutorial you can follow this link: Start of the tutorial: making a Derivative Idle clone with Svelte\n https://svelte.dev/\r[return] http://gzgreg.github.io/DerivativeClicker/\r[return] https://reactjs.org/\r[return] https://angular.io/\r[return] https://aurelia.io/\r[return] https://svelte.dev/tutorial/basics\r[return] https://svelte.dev/repl/hello-world?version=3.5.1\r[return] https://vuejs.org/\r[return] https://svelte.dev/blog/the-easiest-way-to-get-started\r[return] https://git-scm.com/\r[return] https://www.npmjs.com/\r[return] https://yarnpkg.com/en/\r[return] https://webpack.js.org/\r[return] https://rollupjs.org/guide/en/\r[return] http://browserify.org/\r[return] https://zeit.co/now\r[return] https://surge.sh/\r[return] https://sapper.svelte.dev/\r[return] https://github.com/zeit/next.js [return]   ","permalink":"https://www.julienrouse.com/blog/introduction-to-svelte/","tags":["svelte","SPA"],"title":"Introduction to Svelte"},{"categories":null,"contents":" Professional Scrum Developer certification post-mortem I\u0026rsquo;m not sure post-mortem is the right expression.\nAnyway, a few weeks ago I obtained the PSD1 certification from scrum.org and this is a recap on my learning experience. Also at the end there are tips for you if you want to try it as well!\nDisclaimer about certifications Certifications are a cash cow for the very lucrative professional training industry, no doubts. Some certifications are good, some are bad, some are total scams. And they are not well received in all organizations. Nevertheless sometimes they hold some value (even if it is only the value of motivating you to learn new things in exchange of a useless shiny piece of (electronic) paper.)\nAs for PSD1, I have no idea which category it belongs to. It definitely is worth it if your employer pay for it or if it enable a raise and/or enable you to have access to more job opportunities (or mission opportunities for consultants).\nMotivations I had some spare time at work between missions so in parallel with getting myself up to date with front-end technologies (Flutter, Dart, NativeScript), I spent some times learning and training myself for this certification.\nWhat I was hoping to get out of it:\n Getting access to mission needing Agile/Scrum experience. I had some exposure to Scrum and Kanban during a 8 weeks summer job in an web agency in the past (using Java, Spring and some JavaScript and jQuery) but a few times this year it was not enough to be selected for that mission. Actually learning more about Scrum. As it turns out, I knew already most of the topics covered (more than what I anticipated).  As bonus motivation, I had the privilege to have my colleague Nathalie (a very experienced Agile coach) give me a training session on Scrum and Agility and when she was at the office she took the time to answer my questions which was very very valuable! Thanks very much to her!\nMy journey I first started practicing for this test back in October 2018.\nI read the Scrum Guide in French, then practiced with the quiz on scrum.org (they call it \u0026ldquo;Open Assessments\u0026rdquo;) at least four times a day. I was doing mostly the \u0026ldquo;Scrum Developer Open\u0026rdquo; one, but also the \u0026ldquo;Scrum Open\u0026rdquo; which is more generalist.\nOne caveat was that both the open assessments and the real test are in English and I had prepared in French. Most of the terms were understandable but sometimes I got confused and I began again reading and studying the Scrum Guide in English.\nWhen my mission started I kept practicing, doing two to three quiz in the evening when I got home. I kept doing it for three weeks. After all that, I was scoring consistently above 95% (passing grades are 80%) so I was feeling pretty confident.\nBut then life happened, I stopped taking time for training and I stopped practicing altogether.\nIt\u0026rsquo;s only in the beginning of May 2019 that I came back to the certification (and after having completed a Coursera course \u0026ldquo;Learning how to learn\u0026rdquo; which gives some insight on how to learn more effectively). It was a good surprise to me when I started doing practice tests again that I still remembered a lot of the material and started scoring above 90% right away. In retrospective and with what I learned in the Coursera course, I think I remembered so much because I spaced my learning over the span of many weeks, and I took a lot of practice test. Both are good ways to enhance retention in long term memory.\nThen after only a few day of being back to practice, I decided to attempt the certification. I was feeling ready and scored 100% at every test attempt for two days straight.\nThe exam The exam is 80 questions, 60 minutes and you need 85% to pass (at most 12 errors allowed). It cost also 200$USD (269$CAD at the time I bought it), which is not a lot for a certification but still enough for being motivated to not screw it up.\nAnd my impression on it was that it was hard! After acing every test I thought it would be a piece of cake but not at all.\nWhile the exam focus on majority on what the practice exam test you on, there are also questions relevant to a Product Owner or a Scrum Master role in the scrum team. I did not prepare very well for Scrum Master nor Product Owner questions (out of all the tests I did, only 3 or 4 were about Scrum Master and 1 only about Product owner) because in the certification details they said to prepare with the 2 open assessments I used. It was a bad move on my part.\nIn the end, my two months summer job in a scrum team in 2012 helped me figure out some of the \u0026ldquo;hard\u0026rdquo; questions, and I passed the exam successfully.\nIf there is one lesson to remember here: When preparing for any kind of exam, don\u0026rsquo;t prepare exclusively for the subject matter, open your perspective and learn more than what is expected. Also a side benefit is that you actually gain more knowledge and over the course of many months/years, it can be really significant to have pushed for a little more knowledge in term of your global comprehension.\nTips for earning the PSD1 certificate  Do a lot of open assessments: Scrum Developper Open and Scrum Open Read the Scrum Guide (I recommend in English because the exam is exclusively in English) Do a lot of open assessments again: Scrum Developper Open, Scrum Open and also Product Owner Open and Nexus Open Space out your learning, try to do it a little bit every day for at least 2-3 weeks instead of cramming all practice in 1-2 days. You might be able to take the exam successfully if you cram, but you won\u0026rsquo;t build long term memories about what you learn. And while having the certification is great, gaining the knowledge for a long time is more important. Read books and articles about Scrum, Agility, TDD, refactoring, Continuous Integration, Continuous Deployment, and more! The Agile Manifesto is a good start, then look at the Suggested Read List for PSD on scrum.org. (Mind that most of those are affiliate links.) If you have experienced scrum practitioners around you available to help you, jump on the occasion. As with most discipline, the insights of an experienced peer can really help you increase your knowledge very quickly.  Additionally if you have the means, there are training sessions but it is very expensive. A 3 day session in Ottawa for preparing PSD is approximatively 2000$CAD (1482$USD at the time of writing). O_O\nThere are also other website offering training sessions as an alternative if you want to shop for a better price.\nMy opinion on training for PSD is that it is probably not worth it (even if your employer pays for it) as the learning material is very abundant and the open assessments gives you 75% of what you need to know.\nBragging :)   ","permalink":"https://www.julienrouse.com/blog/professional-scrum-developer-certification-post-mortem/","tags":["certification","scrum","scrum.org","post-mortem"],"title":"PSD1 certification post-mortem"},{"categories":null,"contents":"A Reddit bot that read posts and comments from a subreddit, tokenize them and output a wordcloud. The shape of the wordcloud can be configured.\nIt is a very small project, was one of my first \u0026ldquo;real-world\u0026rdquo; project using a third-party API.\n","permalink":"https://www.julienrouse.com/projects/creations/reddit_bot/","tags":["python","nltk","praw","reddit","bot","python","readthedocs.io","wordcloud"],"title":"Reddit bot to make a wordcloud"},{"categories":null,"contents":" This file exists solely to respond to /search URL with the related search layout template.\nNo content shown here is rendered, all content is based in the template layouts/page/search.html\nSetting a very low sitemap priority will tell search engines this is not important content.\nThis implementation uses Fusejs, jquery and mark.js\nInitial setup Search depends on additional output content type of JSON in config.toml\n1 2  [outputs] home = [\u0026#34;HTML\u0026#34;, \u0026#34;JSON\u0026#34;]   Searching additional fields To search additional fields defined in front matter, you must add it in 2 places.\nEdit layouts/_default/index.JSON This exposes the values in /index.json i.e. add category\n1 2 3 4 5 6  ... \u0026#34;contents\u0026#34;:{{ .Content | plainify | jsonify }} {{ if .Params.tags }}, \u0026#34;tags\u0026#34;:{{ .Params.tags | jsonify }}{{end}}, \u0026#34;categories\u0026#34; : {{ .Params.categories | jsonify }}, ...   Edit fuse.js options to Search static/js/search.js\n1 2 3 4 5 6  keys: [ \u0026#34;title\u0026#34;, \u0026#34;contents\u0026#34;, \u0026#34;tags\u0026#34;, \u0026#34;categories\u0026#34; ]  ","permalink":"https://www.julienrouse.com/search/","tags":null,"title":"Search Results"}]