<!DOCTYPE html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
<script>
    window.klipse_settings = {
         selector: '.language-klipse',// css selector for the html elements you want to klipsify
         selector_reagent: '.language-reagent', // selector for reagent snippets
		codemirror_options_in: {
			indentUnit: 8,
			lineWrapping: true,
			lineNumbers: true,
			autoCloseBrackets: true
		},
		codemirror_options_out: {
			lineWrapping: true,
			lineNumbers: true
		}
	}
</script>
</head>
<body>

<pre><code class="language-klipse">(map inc [1 2 3])
</code></pre>

<pre><code class="language-reagent">
(ns my.reagent-examples
  (:require [reagent.core :as r]))

(when-let [element (js/document.getElementById "app")]
  (r/render-component [component] element))
 
(defn greetings []
   [:p "Hello world"])
</code></pre>

<pre><code class="language-reagent">
(ns my.reagent-examples
  (:require [reagent.core :as r]))

(def data (r/atom {:pv 180 :pvmax 300 :mana 80}))
(def datapv (r/atom 100))

(defn healthbar [pv pvmax]
  [:div {:value :value :style {:color "red" :width (str (int (* (/ pv pvmax) 100)) "%") :background-color "blue" :border "1px solid black"}} (str (int (* (/ pv pvmax) 100)) "%")])

(defn buy [atom1 key1 qtty]
    (swap! atom1 merge {key1 (- (@atom1 key1) qtty)}))

(defn sell [atom1 key1 qtty]
    (swap! atom1 merge {key1 (+ (@atom1 key1) qtty)}))

(defn container-green [component]
  [:div {:style {:color "green" }}
   component])

(defn t []
  (let [{:keys [pv pvmax mana] :as datadata} @data])
  [:div
   [:p pvmax]
   [:p "toto"]
   [healthbar (@data :pv) (@data :pvmax)]
   [healthbar (- (@data :pv) 50) (@data :pvmax)]
   [healthbar 50 1000]
   [healthbar @datapv 100]
   [:input {:type "button" :value "lose health" :on-click (fn [e] (swap! datapv dec)) } ]
   [:input {:type "button" :value "gain health" :on-click (fn [e] (swap! data merge {:pv (+ (@data :pv) 10)})) } ]
   [:input {:type "button" :value "increase max health" :on-click (fn [e] (swap! data merge {:pvmax (+ (@data :pvmax) 50)}))}]
   [:input {:type "button" :value "buy 1" :on-click #(buy data :mana 5)}]
   [:p @datapv]
   [:p (str (@data :pvmax) "pvmax")]
   [:p (str (@data :pv) "pv" )]
   [:p (str (@data :mana) "mana" )]
   ])

(defn tt []
  (container-green (t)))
</code></pre>

<pre><code class="language-reagent">
(ns my.reagent-examples
        (:require [reagent.core :as r]))

(defn make-cotcot 
        [initial-cost cost-multiplier initial-earning description] 
        {:initial-cost initial-cost :cost-multiplier cost-multiplier :initial-earning initial-earning :quantity 0 :description description})

(defn make-upgrade
        [name description cost benefit]
        {:name name :description description :cost cost :benefit benefit :bought false})

(defonce dataCotCot (r/atom {:currency 20 :lvl1 0 :lvl2 0}))
(def test (r/atom {:currency 20
                   :lifetime-earning 0
                   :lvl1 (make-cotcot 10 1.07 0.5 "petite poulette") 
                   :lvl2 (make-cotcot 100 1.1 2 "moyenne poulette") 
                   :lvl3 (make-cotcot 1000 1.13 10 "grande poulette")
                   :lvl4 (make-cotcot 100000 1.14 100 "mega poulette")
                   :upgrade-multiplier 1
                   :upgrades {:upgrade1 (make-upgrade "upgrade1" "description1 blabla" 10 0.01)
                              :upgrade2 (make-upgrade "upgrade2" "description2 bloblo" 100 0.1)}
                   :reset-multiplier 1}))


(defn calc-cost [qtty initial-cost lvl]
        (if (= qtty 0)
                initial-cost
                (int (Math/pow initial-cost (+ 1 (/ qtty 10) (/ lvl 10))))))

(defn calc-cost2 [my-atom lvl-key]
        (let [initial-cost ((@my-atom lvl-key) :initial-cost)
              quantity ((@my-atom lvl-key) :quantity)
              cost-multiplier ((@my-atom lvl-key) :cost-multiplier)]
                (if (<= quantity 0)
                        initial-cost
                        (int (Math/pow initial-cost (+ 1 (/ quantity 10) (/ cost-multiplier 10)))))))
(defn calc-cost2-1 [my-atom lvl-key]
        (let [initial-cost ((@my-atom lvl-key) :initial-cost)
              quantity ((@my-atom lvl-key) :quantity)
              cost-multiplier ((@my-atom lvl-key) :cost-multiplier)]
                (int (+ (* initial-cost (Math/pow cost-multiplier quantity)) quantity))))

(defn add-upgrade-mult [my-atom multiplier]
        (swap! my-atom update-in [:upgrade-multiplier] + multiplier))

(defn sell2 [my-atom lvl-key quantity]
        (swap! my-atom update-in [lvl-key :quantity] + quantity))

(defn buyCotCot [myatom currencykey lvlkey qtty]
        (when (<= qtty (@myatom currencykey)) 
                (fn [e]
                        (buy dataCotCot currencykey qtty)
                        (sell dataCotCot lvlkey 1))))

(defn buyCotCot2 [my-atom currency-key lvl-key]
        (let [cost (calc-cost2-1 my-atom lvl-key)]
                (when (<= cost (@my-atom :currency))
                        (fn [e]
                                (buy my-atom currency-key cost)
                                (sell2 my-atom lvl-key 1)))))

(defn value-per-tick [my-atom lvl-key]
        (let [lvl-stat (@my-atom lvl-key)
              upgrade-multiplier (@my-atom :upgrade-multiplier)
              reset-multiplier (@my-atom :reset-multiplier)]
                (* (lvl-stat :quantity) (lvl-stat :initial-earning) upgrade-multiplier reset-multiplier)))

(defn total-earning-per-tick [my-atom my-keys]
        (reduce + (map value-per-tick (repeat my-atom) my-keys)))

(defn update-ressource [atom1]
        (swap! atom1 merge {:currency (+ (@atom1 :currency) (+ (@atom1 :lvl1) (* (@atom1 :lvl2) 10)))}))
(defn update-ressource2 [atom1]
        (swap! atom1 merge {:currency (+ (@atom1 :currency) (total-earning-per-tick atom1 [:lvl1 :lvl2 :lvl3 :lvl4]))}))

(defonce timer-update-ressource
        (js/setInterval #(update-ressource dataCotCot) 1000)) ;; Increment app-state every 1000ms
(defonce timer-update-ressource2
        (js/setInterval #(update-ressource2 test) 1000)) ;; Increment app-state every 1000ms

(defn cotcot-component [my-atom lvl-key]
        [:input {:type "button" :value (str "Buy 1 " ((@my-atom lvl-key) :description) " for " (calc-cost2-1 my-atom lvl-key) "$(" ((@my-atom lvl-key) :quantity) ")") :on-click (buyCotCot2 my-atom :currency lvl-key)}])

(defn upgrade-component [my-atom upgrade-key]
        (let [upgrade ((@my-atom :upgrades) upgrade-key)]
                (when-not (upgrade :bought)
                        [:input {:type "button" 
                                 :value (upgrade :name)
                                 :disabled (>= (upgrade :cost) (@my-atom :currency))
                                 :on-click (fn [e]
                                                   (swap! my-atom update-in [:upgrades upgrade-key :bought] (fn [e] true))
                                                   (buy my-atom :currency (upgrade :cost))
                                                   (add-upgrade-mult my-atom (upgrade :benefit)))}])))

(defn cotcotidle []
        [:div
         [:input {:type "button" :value "buy 1 Poulette" :on-click (buyCotCot  dataCotCot :currency :lvl1 (calc-cost (@dataCotCot :lvl1) 10 1))}]
         [:input {:type "button" :value "buy 1 Poulette gold" :on-click (buyCotCot  dataCotCot :currency :lvl2 (calc-cost (@dataCotCot :lvl2) 100 2))}]
         [:p (str (@dataCotCot :currency) " Oeuf(s)")]
         [:p (str (@dataCotCot :lvl1) " Poulette!")]
         [:p (str (@dataCotCot :lvl2) " Poulette gold?")]
         [:p (str "cost for lvl1 is " (calc-cost (@dataCotCot :lvl1) 10 1))]
         [:p (str "cost for lvl2 is " (calc-cost (@dataCotCot :lvl2) 100 2))]
         [:p (str "test " @test)]
         ])

(defn cotcotidle2 []
        [:div
         [cotcot-component test :lvl1]
         [cotcot-component test :lvl2]
         [cotcot-component test :lvl3]
         [cotcot-component test :lvl4]
         [:div 
          [:p "upgrade"]
          [upgrade-component test :upgrade1]
          ]
         [:p (str (Math/floor (@test :currency)) " Oeuf(s)")]
         [:p (str "$/tick:" (total-earning-per-tick test [:lvl1 :lvl2 :lvl3]))]
         [:p (str "test: " @test)]
         ])
</code></pre>

<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>
</body>