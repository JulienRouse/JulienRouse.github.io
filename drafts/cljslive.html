<!DOCTYPE html>
<head>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="https://storage.googleapis.com/app.klipse.tech/css/codemirror.css">
<script>
    window.klipse_settings = {
         selector: '.language-klipse',// css selector for the html elements you want to klipsify
         selector_reagent: '.language-reagent', // selector for reagent snippets
    };
</script>
</head>
<body>

<pre><code class="language-klipse">(map inc [1 2 3])
</code></pre>

<pre><code class="language-reagent">
(ns my.reagent-examples
  (:require [reagent.core :as r]))

(when-let [element (js/document.getElementById "app")]
  (r/render-component [component] element))
 
(defn greetings []
   [:p "Hello world"])
</code></pre>

<pre><code class="language-reagent">
(ns my.reagent-examples
  (:require [reagent.core :as r]))

(def data (r/atom {:pv 180 :pvmax 300 :mana 80}))
(def datapv (r/atom 100))

(defn healthbar [pv pvmax]
  [:div {:value :value :style {:color "red" :width (str (int (* (/ pv pvmax) 100)) "%") :background-color "blue" :border "1px solid black"}} (str (int (* (/ pv pvmax) 100)) "%")])

(defn buy [atom1 key1 qtty]
    (swap! atom1 merge {key1 (- (@atom1 key1) qtty)}))

(defn sell [atom1 key1 qtty]
    (swap! atom1 merge {key1 (+ (@atom1 key1) qtty)}))

(defn container-green [component]
  [:div {:style {:color "green" }}
   component])

(defn t []
  (let [{:keys [pv pvmax mana] :as datadata} @data])
  [:div
   [:p pvmax]
   [:p "toto"]
   [healthbar (@data :pv) (@data :pvmax)]
   [healthbar (- (@data :pv) 50) (@data :pvmax)]
   [healthbar 50 1000]
   [healthbar @datapv 100]
   [:input {:type "button" :value "lose health" :on-click (fn [e] (swap! datapv dec)) } ]
   [:input {:type "button" :value "gain health" :on-click (fn [e] (swap! data merge {:pv (+ (@data :pv) 10)})) } ]
   [:input {:type "button" :value "increase max health" :on-click (fn [e] (swap! data merge {:pvmax (+ (@data :pvmax) 50)}))}]
   [:input {:type "button" :value "buy 1" :on-click #(buy data :mana 5)}]
   [:p @datapv]
   [:p (str (@data :pvmax) "pvmax")]
   [:p (str (@data :pv) "pv" )]
   [:p (str (@data :mana) "mana" )]
   ])

(defn tt []
  (container-green (t)))
</code></pre>

<pre><code class="language-reagent">
(ns my.reagent-examples
  (:require [reagent.core :as r]))

(defn make-cotcot 
  [initial-cost cost-multiplier initial-earning description] 
  {:initial-cost initial-cost :cost-multiplier cost-multiplier :initial-earning initial-earning :quantity 0 :description description})

(defonce dataCotCot (r/atom {:currency 20 :lvl1 0 :lvl2 0}))
(def test (r/atom {:currency 20 
                   :lvl1 (make-cotcot 10 1.07 0.5 "petite poulette") 
                   :lvl2 (make-cotcot 100 1.1 2 "moyenne poulette") 
                   :lvl3 (make-cotcot 1000 1.13 10 "grande poulette")
                   :lvl4 (make-cotcot 100000 1.14 100 "mega poulette")
                   :upgrade-multiplier 1
                   :reset-multiplier 1}))


(defn calc-cost [qtty initial-cost lvl]
  (if (= qtty 0)
    initial-cost
    (int (Math/pow initial-cost (+ 1 (/ qtty 10) (/ lvl 10))))))

(defn calc-cost2 [my-atom lvl-key]
  (let [initial-cost ((@my-atom lvl-key) :initial-cost)
        quantity ((@my-atom lvl-key) :quantity)
        cost-multiplier ((@my-atom lvl-key) :cost-multiplier)]
    (if (<= quantity 0)
      initial-cost
      (int (Math/pow initial-cost (+ 1 (/ quantity 10) (/ cost-multiplier 10)))))))
(defn calc-cost2-1 [my-atom lvl-key]
  (let [initial-cost ((@my-atom lvl-key) :initial-cost)
        quantity ((@my-atom lvl-key) :quantity)
        cost-multiplier ((@my-atom lvl-key) :cost-multiplier)]
    (int (+ (* initial-cost (Math/pow cost-multiplier quantity)) quantity))))


(defn sell2 [my-atom lvl-key quantity]
  (swap! my-atom update-in [lvl-key :quantity] + quantity))

(defn buyCotCot [myatom currencykey lvlkey qtty]
  (when (<= qtty (@myatom currencykey)) 
    (fn [e]
      (buy dataCotCot currencykey qtty)
      (sell dataCotCot lvlkey 1))))

(defn buyCotCot2 [my-atom currency-key lvl-key]
  (let [cost (calc-cost2-1 my-atom lvl-key)]
    (when (<= cost (@my-atom :currency))
      (fn [e]
        (buy my-atom currency-key cost)
        (sell2 my-atom lvl-key 1)))))

(defn value-per-tick [my-atom lvl-key]
  (let [lvl-stat (@my-atom lvl-key)
        upgrade-multiplier (@my-atom :upgrade-multiplier)
        reset-multiplier (@my-atom :reset-multiplier)]
	(* (lvl-stat :quantity) (lvl-stat :initial-earning) upgrade-multiplier reset-multiplier)))

(defn total-earning-per-tick [my-atom my-keys]
	(map value-per-tick (repeat my-atom) my-keys))
  ;(map value-per-tick  my-atom my-keys))

(defn update-ressource [atom1]
  (swap! atom1 merge {:currency (+ (@atom1 :currency) (+ (@atom1 :lvl1) (* (@atom1 :lvl2) 10)))}))
(defn update-ressource2 [atom1]
  (swap! atom1 merge {:currency (+ (@atom1 :currency) (total-earning-per-tick atom1 [:lvl1 :lvl2 :lvl3 :lvl4]))}))

(defonce timer-update-ressource
  (js/setInterval #(update-ressource dataCotCot) 1000)) ;; Increment app-state every 1000ms
(defonce timer-update-ressource2
  (js/setInterval #(update-ressource2 test) 1000)) ;; Increment app-state every 1000ms

(defn cotcot-component [my-atom lvl-key]
  [:input {:type "button" :value (str "Buy 1 " ((@my-atom lvl-key) :description) " for " (calc-cost2-1 my-atom lvl-key) "$(" ((@my-atom lvl-key) :quantity) ")") :on-click (buyCotCot2 my-atom :currency lvl-key)}])


(defn cotcotidle []
  [:div
   [:input {:type "button" :value "buy 1 Poulette" :on-click (buyCotCot  dataCotCot :currency :lvl1 (calc-cost (@dataCotCot :lvl1) 10 1))}]
   [:input {:type "button" :value "buy 1 Poulette gold" :on-click (buyCotCot  dataCotCot :currency :lvl2 (calc-cost (@dataCotCot :lvl2) 100 2))}]
   [:p (str (@dataCotCot :currency) " Oeuf(s)")]
   [:p (str (@dataCotCot :lvl1) " Poulette!")]
   [:p (str (@dataCotCot :lvl2) " Poulette gold?")]
   [:p (str "cost for lvl1 is " (calc-cost (@dataCotCot :lvl1) 10 1))]
   [:p (str "cost for lvl2 is " (calc-cost (@dataCotCot :lvl2) 100 2))]
   [:p (str "test " @test)]
   ])

(defn cotcotidle2 []
  [:div
   [cotcot-component test :lvl1]
   [cotcot-component test :lvl2]
   [cotcot-component test :lvl3]
   [cotcot-component test :lvl4]
   ;[:input {:type "button" :value "buy 1 lvl1" :on-click (buyCotCot2 test :currency :lvl1)}]
   ;[:input {:type "button" :value "buy 1 lvl2" :on-click (buyCotCot2 test :currency :lvl2)}]
   ;[:input {:type "button" :value "buy 1 lvl3" :on-click (buyCotCot2 test :currency :lvl3)}]
   [:p (str (Math/floor (@test :currency)) " Oeuf(s)")]
   ;[:p (str ((@test :lvl1) :quantity) " Poulette lvl1!")]
   ;[:p (str ((@test :lvl2) :quantity) " Poulette lvl2!")]
   ;[:p (str ((@test :lvl3) :quantity) " Poulette lvl3!")]
   ;[:p (str (calc-cost2-1 test :lvl1) " cost lvl1!")]
   ;[:p (str (calc-cost2-1 test :lvl2) " cost lvl2!")]
   ;[:p (str (calc-cost2-1 test :lvl3) " cost lvl3!")]
   [:p (str "earning per tick" (total-earning-per-tick test [:lvl1 :lvl2 :lvl3]))]
   [:p (str "test: " @test)]
   ])
</code></pre>

<script src="https://storage.googleapis.com/app.klipse.tech/plugin/js/klipse_plugin.js"></script>
</body>